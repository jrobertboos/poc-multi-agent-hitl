import json
import requests
import time

from llama_stack.apis.agents import AgentConfig, AgentTurnCreateRequest
from llama_stack.log import get_logger
from llama_stack.providers.inline.agents.meta_reference.agent_instance import ChatAgent
from llama_stack.providers.utils.telemetry import tracing

from llama_stack.apis.inference import (
    Inference,
    UserMessage,
    SamplingParams,
    TopPSamplingStrategy,
)

from llama_stack.apis.safety import Safety
from llama_stack.apis.tools import ToolGroups, ToolInvocationResult, ToolRuntime
from llama_stack.apis.vector_io import VectorIO
from llama_stack.providers.utils.kvstore import KVStore

from llama_stack.models.llama.datatypes import (
     BuiltinTool,
     ToolCall,
)

logger = get_logger(name=__name__, category="agents")

class HitlChatAgent(ChatAgent):
    def __init__(
            self,
            agent_id: str,
            agent_config: AgentConfig,
            inference_api: Inference,
            safety_api: Safety,
            tool_runtime_api: ToolRuntime,
            tool_groups_api: ToolGroups,
            vector_io_api: VectorIO,
            persistence_store: KVStore,
            created_at: str,
            hil_endpoint: str,
            ):
        super().__init__(
                agent_id,
                agent_config,
                inference_api,
                safety_api,
                tool_runtime_api,
                tool_groups_api,
                vector_io_api,
                persistence_store,
                created_at,
                )
        self.hil_endpoint = hil_endpoint

    def _post_approval(self, tool_name, agent_id, session_id, status=None):
        payload = {
                "tool_name": tool_name,
                "agent_id": agent_id,
                "session_id": session_id,
                "status": status
                }

        payload = {k: v for k, v in payload.items() if v is not None}

        response = requests.post(f"{self.hil_endpoint}/approvals", json=payload)

        if response.status_code == 200:
            approval = response.json()
            return approval
        else:
            print("Error:", response.status_code, response.text)
            return None

    def _wait_for_approval(self, approval_id, interval=2, timeout=120):
        """
        Polls the approval status until it becomes True, or times out.

        Args:
            approval_id (str): The ID of the approval to monitor.
            interval (int): Polling interval in seconds.
            timeout (int): Maximum time to wait in seconds.

        Returns:
            dict: The approval object if status is True.
            None: If timeout is reached or error occurs.
        """
        start_time = time.time()

        while time.time() - start_time < timeout:
            response = requests.get(f"{self.hil_endpoint}/approvals/{approval_id}")
            if response.status_code == 200:
                approval = response.json()
                if approval.get("status") is not None:
                    return approval
            else:
                print("Error:", response.status_code, response.text)
                return None

            time.sleep(interval)

        print("Timeout reached while waiting for approval status to be true.")
        return None

    async def execute_tool_call_maybe(
            self,
            session_id: str,
            tool_call: ToolCall,
            ) -> ToolInvocationResult:
        tool_name = tool_call.tool_name
        registered_tool_names = {}
        for tool in self.tool_defs:
            registered_tool_names[tool.tool_name] = tool
        if tool_name not in registered_tool_names:
            raise ValueError(
                    f"Tool {tool_name} not found in provided tools, registered tools: {', '.join([str(x) for x in registered_tool_names])}"
                    )
        
        if isinstance(tool_name, BuiltinTool):
            if tool_name == BuiltinTool.brave_search:
                tool_name_str = WEB_SEARCH_TOOL
            else:
                tool_name_str = tool_name.value
        else:
            tool_name_str = tool_name

        is_destructive = (
            registered_tool_names[tool_name].annotations.get("destructiveHint", False)
            if registered_tool_names[tool_name].annotations else False
        )
        if is_destructive:
            approval_id = self._post_approval(tool_name, self.agent_id, session_id).get("id")

            approved = self._wait_for_approval(approval_id).get("status")
        else:
            approved = True
            
        if approved:
            logger.info(f"executing tool call: {tool_name_str} with args: {tool_call.arguments}")
            result = await self.tool_runtime_api.invoke_tool(
                    tool_name=tool_name_str,
                    kwargs={
                        "session_id": session_id,
                        # get the arguments generated by the model and augment with toolgroup arg overrides for the agent
                        **tool_call.arguments,
                        **self.tool_name_to_args.get(tool_name_str, {}),
                        },
                    )
            logger.debug(f"tool call {tool_name_str} completed with result: {result}")
            return result
        else:
            raise ValueError(f"Tool {tool_name} was rejected")

